<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedListSortingAndSearching.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Projeto_ED_GRUPO14</a> &gt; <a href="index.source.html" class="el_package">collections.implementation</a> &gt; <span class="el_source">LinkedListSortingAndSearching.java</span></div><h1>LinkedListSortingAndSearching.java</h1><pre class="source lang-java linenums">
package collections.implementation;

<span class="nc" id="L4">public class LinkedListSortingAndSearching&lt;T&gt; {</span>

    //------------------------Algoritmos de pesquisa----------------------------

    /**
     * Searches a specified element on a single linked list
     * using a linear search algorithm.
     *
     * @param &lt;T&gt;
     * @param head   beginning of single linked list
     * @param target the element being searched for
     * @return true if the desired element is found
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; boolean linearSearch(LinkedNode head, T target) {
<span class="nc" id="L18">        LinkedNode&lt;T&gt; current = head;</span>
<span class="nc" id="L19">        boolean found = false;</span>
<span class="nc bnc" id="L20" title="All 4 branches missed.">        while (current != null &amp;&amp; !found) {</span>
<span class="nc bnc" id="L21" title="All 2 branches missed.">            if (target.equals(current.getElement()))</span>
<span class="nc" id="L22">                found = true;</span>
            else {
<span class="nc" id="L24">                current = current.getNext();</span>
            }
        }
<span class="nc" id="L27">        return found;</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; boolean RecursivelinearSearch(LinkedNode&lt;T&gt; head, T target) {
<span class="nc bnc" id="L31" title="All 2 branches missed.">        if (head != null) {</span>
<span class="nc" id="L32">            return false;</span>
        }
<span class="nc bnc" id="L34" title="All 2 branches missed.">        if (target.compareTo(head.getElement()) == 0) {</span>
<span class="nc" id="L35">            return true;</span>
        }
<span class="nc" id="L37">        return RecursivelinearSearch(head.getNext(), target);</span>
    }

    /**
     * Function to find middle element
     * @param head beginning of single linked list
     * @param tail ending of single linked list
     * @return
     */
    public static LinkedNode&lt;Integer&gt; getMiddleNode(LinkedNode&lt;Integer&gt; head, LinkedNode&lt;Integer&gt; tail) {
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (head == null) {</span>
<span class="nc" id="L48">            return null;</span>
        }

<span class="nc" id="L51">        LinkedNode&lt;Integer&gt; slow = head;</span>
<span class="nc" id="L52">        LinkedNode&lt;Integer&gt; fast = head.getNext();</span>

<span class="nc bnc" id="L54" title="All 2 branches missed.">        while (fast != tail) {</span>
<span class="nc" id="L55">            fast = fast.getNext();</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">            if (fast != tail) {</span>
<span class="nc" id="L57">                slow = slow.getNext();</span>
<span class="nc" id="L58">                fast = fast.getNext();</span>
            }
        }
<span class="nc" id="L61">        return slow;</span>
    }

    /**
     * function to insert a node at the beginning of the Singly Linked List
     * @param head
     * @param value
     * @return
     */
    public static LinkedNode&lt;Integer&gt; binarySearch(LinkedNode&lt;Integer&gt; head, int value) {
<span class="nc" id="L71">        LinkedNode&lt;Integer&gt; start = head;</span>
<span class="nc" id="L72">        LinkedNode&lt;Integer&gt; last = null;</span>

        do {
            // Find Middle
<span class="nc" id="L76">            LinkedNode&lt;Integer&gt; mid = getMiddleNode(start, last);</span>

            // If middle is empty
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (mid == null)</span>
<span class="nc" id="L80">                return null;</span>

            // If value is present at middle
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (mid.getElement() == value)</span>
<span class="nc" id="L84">                return mid;</span>

            // If value is less than mid
<span class="nc bnc" id="L87" title="All 2 branches missed.">            else if (mid.getElement() &gt; value)</span>
            {
<span class="nc" id="L89">                start = mid.getNext();</span>
            }

            // If the value is more than mid.
            else
<span class="nc" id="L94">                last = mid;</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">        } while (last == null || last != start);</span>

        // value not present
<span class="nc" id="L98">        return null;</span>
    }

   //------------------------Algoritmos de ordenaÃ§Ã£o----------------------------

   /**
    * Sorts the specified element on a single linked list using the selection
    * sort algorithm.
    *
    * @param data element to be sorted
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        selectionSort (T data) {

<span class="nc" id="L112">    }</span>

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        insertionSort (T data) {

<span class="nc" id="L117">   }</span>

    /**
    * Sorts the specified array of objects using a bubble sort
    * algorithm.
    *
    * @param data the array to be sorted
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void bubbleSort (T data) {

<span class="nc" id="L127">    }</span>

    private static LinkedNode&lt;Integer&gt; paritionLast(LinkedNode&lt;Integer&gt; start, LinkedNode&lt;Integer&gt; end) {
<span class="nc bnc" id="L130" title="All 6 branches missed.">        if (start == end || start == null || end == null)</span>
<span class="nc" id="L131">            return start;</span>

<span class="nc" id="L133">        LinkedNode&lt;Integer&gt; pivot_prev = start;</span>
<span class="nc" id="L134">        LinkedNode&lt;Integer&gt; curr = start;</span>
<span class="nc" id="L135">        int pivot = end.getElement();</span>

        // iterate till one before the end,
        // no need to iterate till the end
        // because end is pivot
<span class="nc bnc" id="L140" title="All 2 branches missed.">        while (start != end) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (start.getElement() &lt; pivot) {</span>
                // keep tracks of last modified item
<span class="nc" id="L143">                pivot_prev = curr;</span>
<span class="nc" id="L144">                int temp = curr.getElement();</span>
<span class="nc" id="L145">                curr.setElement(start.getElement());</span>
<span class="nc" id="L146">                start.setElement(temp);</span>
<span class="nc" id="L147">                curr = curr.getNext();</span>
            }
<span class="nc" id="L149">            start = start.getNext();</span>
        }

        // swap the position of curr i.e.
        // next suitable index and pivot
<span class="nc" id="L154">        int temp = curr.getElement();</span>
<span class="nc" id="L155">        curr.setElement(pivot);</span>
<span class="nc" id="L156">        end.setElement(temp);</span>

        // return one previous to current
        // because current is now pointing to pivot
<span class="nc" id="L160">        return pivot_prev;</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(LinkedNode&lt;Integer&gt; start, LinkedNode&lt;Integer&gt; end) {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if(start == end )</span>
<span class="nc" id="L165">            return;</span>

        // split list and partion recurse
<span class="nc" id="L168">        LinkedNode&lt;Integer&gt; prev = paritionLast(start, end);</span>
<span class="nc" id="L169">        quickSort(start, prev);</span>

        // if pivot is picked and moved to the start,
        // that means start and pivot is same
        // so pick from next of pivot
<span class="nc bnc" id="L174" title="All 4 branches missed.">        if( prev != null &amp;&amp; prev == start )</span>
<span class="nc" id="L175">            quickSort(prev.getNext(), end);</span>

        // if pivot is in between of the list,
        // start from next of pivot,
        // since we have pivot_prev, so we move two nodes
<span class="nc bnc" id="L180" title="All 2 branches missed.">        else if(prev != null &amp;&amp;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                prev.getElement() != null)</span>
<span class="nc" id="L182">            quickSort(prev.getNext().getNext(), end);</span>
<span class="nc" id="L183">    }</span>

    private static LinkedNode&lt;Integer&gt; sortedMerge(LinkedNode&lt;Integer&gt; a, LinkedNode&lt;Integer&gt; b) {
<span class="nc" id="L186">        LinkedNode&lt;Integer&gt; result = null;</span>
        /* Base cases */
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L189">            return b;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (b == null)</span>
<span class="nc" id="L191">            return a;</span>

        /* Pick either a or b, and recur */
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (a.getElement() &lt;= b.getElement()) {</span>
<span class="nc" id="L195">            result = a;</span>
<span class="nc" id="L196">            result.setNext(sortedMerge(a.getNext(), b));</span>
        }
        else {
<span class="nc" id="L199">            result = b;</span>
<span class="nc" id="L200">            result.setNext(sortedMerge(a, b.getNext()));</span>
        }
<span class="nc" id="L202">        return result;</span>
    }

    public static LinkedNode getMiddle(LinkedNode head) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (head == null)</span>
<span class="nc" id="L207">            return head;</span>

<span class="nc" id="L209">        LinkedNode slow = head, fast = head.getNext();</span>

<span class="nc bnc" id="L211" title="All 4 branches missed.">        while (fast != null &amp;&amp; fast.getNext() != null) {</span>
<span class="nc" id="L212">            slow = slow.getNext();</span>
<span class="nc" id="L213">            fast = fast.getNext();</span>
        }
<span class="nc" id="L215">        return slow;</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; LinkedNode mergeSort(LinkedNode h) {
        // Base case : if head is null
<span class="nc bnc" id="L220" title="All 4 branches missed.">        if (h == null || h.getNext() == null) {</span>
<span class="nc" id="L221">            return h;</span>
        }

        // get the middle of the list
<span class="nc" id="L225">        LinkedNode middle = getMiddle(h);</span>
<span class="nc" id="L226">        LinkedNode nextofmiddle = middle.getNext();</span>

        // set the next of middle node to null
<span class="nc" id="L229">        middle.setNext(null);</span>

        // Apply mergeSort on left list
<span class="nc" id="L232">        LinkedNode left = mergeSort(h);</span>

        // Apply mergeSort on right list
<span class="nc" id="L235">        LinkedNode right = mergeSort(nextofmiddle);</span>

        // Merge the left and right lists
<span class="nc" id="L238">        LinkedNode sortedlist = sortedMerge(left, right);</span>
<span class="nc" id="L239">        return sortedlist;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>