<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArraySortingAndSearching.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Projeto_ED_GRUPO14</a> &gt; <a href="index.source.html" class="el_package">collections.implementation</a> &gt; <span class="el_source">ArraySortingAndSearching.java</span></div><h1>ArraySortingAndSearching.java</h1><pre class="source lang-java linenums">
package collections.implementation;



/**
 *
 */
<span class="nc" id="L9">public class ArraySortingAndSearching {</span>
    
    //------------------------Algoritmos de pesquisa----------------------------
    /**
    * Searches the specified array of objects using a linear search algorithm.
    *
    * @param &lt;T&gt;
    * @param data the array to be sorted
    * @param min the integer representation of the min value
    * @param max the integer representation of the max value
    * @param target the element being searched for
    * @return true if the desired element is found
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; boolean 
        linearSearch (T[] data, int min, int max, T target) {
            
<span class="nc" id="L25">        int index = min;</span>
<span class="nc" id="L26">        boolean found = false;</span>
<span class="nc bnc" id="L27" title="All 4 branches missed.">        while (!found &amp;&amp; index &lt;= max) {</span>
<span class="nc bnc" id="L28" title="All 2 branches missed.">            if (data[index].compareTo(target) == 0)</span>
<span class="nc" id="L29">                found = true;</span>
<span class="nc" id="L30">            index++;</span>
        }
<span class="nc" id="L32">        return found;</span>
    }
    
    /**
    * Searches the specified array of objects using a
    * binary search algorithm.
    * @param data the array to be sorted
    * @param min the integer representation of the minimum value
    * @param max the integer representation of the maximum value
    * @param target the element being searched for
    * @return true if the desired element is found
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; boolean
        binarySearch (T[] data, int min, int max, T target) {
          
<span class="nc" id="L47">        boolean found = false;</span>
<span class="nc" id="L48">        int midpoint = (min + max) / 2; // determine the midpoint</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        if (data[midpoint].compareTo(target) == 0)</span>
<span class="nc" id="L50">            found = true;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        else if (data[midpoint].compareTo(target) &gt; 0) {</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">            if (min &lt;= midpoint - 1)</span>
<span class="nc" id="L53">                found = binarySearch(data, min, midpoint - 1, target);</span>
        }
<span class="nc bnc" id="L55" title="All 2 branches missed.">        else if (midpoint + 1 &lt;= max)</span>
<span class="nc" id="L56">            found = binarySearch(data, midpoint + 1, max, target);</span>
<span class="nc" id="L57">        return found;</span>
   }
        
   //------------------------Algoritmos de ordenaÃ§Ã£o----------------------------

   /**
    * Sorts the specified array of integers using the selection
    * sort algorithm.
    *
    * @param data the array to be sorted
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        selectionSort (T[] data) {
      int min;
      T temp;
<span class="nc bnc" id="L72" title="All 2 branches missed.">      for (int index = 0; index &lt; data.length-1; index++) {</span>
<span class="nc" id="L73">        min = index;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (int scan = index+1; scan &lt; data.length; scan++) {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            if (data[scan].compareTo(data[min])&lt;0) {</span>
<span class="nc" id="L76">               min = scan;</span>
            }
        }
        // Swap the values
<span class="nc" id="L80">        temp = data[min];</span>
<span class="nc" id="L81">        data[min] = data[index];</span>
<span class="nc" id="L82">        data[index] = temp;</span>
      }
<span class="nc" id="L84">    }</span>

    /**
    * Sorts the specified array of objects using an insertion
    * sort algorithm.
    *
    * @param data the array to be sorted
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        insertionSort (T[] data) {
<span class="nc bnc" id="L94" title="All 2 branches missed.">      for (int index = 1; index &lt; data.length; index++) {</span>
<span class="nc" id="L95">         T key = data[index];</span>
<span class="nc" id="L96">         int position = index;</span>
         
         // Shift larger values to the right
<span class="nc bnc" id="L99" title="All 4 branches missed.">         while (position &gt; 0 &amp;&amp; data[position-1].compareTo(key) &gt; 0){</span>
<span class="nc" id="L100">            data[position] = data[position-1];</span>
<span class="nc" id="L101">            position--;</span>
         }   
<span class="nc" id="L103">         data[position] = key;</span>
      }
<span class="nc" id="L105">   }</span>

    /**
    * Sorts the specified array of objects using a bubble sort
    * algorithm.
    *
    * @param data the array to be sorted
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void bubbleSort (T[] data) {
        int position, scan;
        T temp;
<span class="nc bnc" id="L116" title="All 2 branches missed.">        for (position = data.length - 1; position &gt;= 0; position--) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            for (scan = 0; scan &lt;= position - 1; scan++) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                if (data[scan].compareTo(data[scan+1]) &gt; 0) {</span>
                    // Swap the values
<span class="nc" id="L120">                    temp = data[scan];</span>
<span class="nc" id="L121">                    data[scan] = data[scan + 1];</span>
<span class="nc" id="L122">                    data[scan + 1] = temp;</span>
                }
            }
        }
<span class="nc" id="L126">    }</span>
    
    /**
    * Sorts the specified array of objects using the quick sort
    * algorithm.
    * Recursive algorithm
    *
    * @param data the array to be sorted
    * @param min the integer representation of the minimum value
    * @param max the integer representation of the maximum value
        */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        quickSort (T[] data, int min, int max) {
        int indexOfPartition;
        
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (max - min &gt; 0) {</span>
            // Create partitions
<span class="nc" id="L143">            indexOfPartition = findPartition(data, min, max);</span>
         
            // Sort the left side
<span class="nc" id="L146">            quickSort(data, min, indexOfPartition - 1);</span>
         
            // Sort the right side
<span class="nc" id="L149">            quickSort(data, indexOfPartition + 1, max);</span>
        }
<span class="nc" id="L151">    }</span>

    /**
    * Used by the quick sort algorithm to find the partition.
    *
    * @param data the array to be sorted
    * @param min the integer representation of the minimum value
    * @param max the integer representation of the maximum value
    */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; int
        findPartition (T[] data, int min, int max) {
            
        int left, right;
        T temp, partitionelement;
<span class="nc" id="L165">        int middle = (min + max)/2;</span>
        
        // use middle element as partition
<span class="nc" id="L168">        partitionelement = data[middle];</span>
<span class="nc" id="L169">        left = min;</span>
<span class="nc" id="L170">        right = max;</span>
        
<span class="nc bnc" id="L172" title="All 2 branches missed.">        while (left &lt; right) {</span>
            // search for an element that is &gt; the partitionElement
<span class="nc bnc" id="L174" title="All 2 branches missed.">            while (data[left].compareTo(partitionelement) &lt; 0) {</span>
<span class="nc" id="L175">                left++;</span>
            }
         
            // search for an element that is &lt; the partitionElement
<span class="nc bnc" id="L179" title="All 2 branches missed.">            while (data[right].compareTo(partitionelement) &gt; 0)</span>
<span class="nc" id="L180">                right--;</span>
            
            // swap the elements
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (left &lt; right) {</span>
<span class="nc" id="L184">                temp = data[left];</span>
<span class="nc" id="L185">                data[left] = data[right];</span>
<span class="nc" id="L186">                data[right] = temp;</span>
            }
        }
        
        // move partition element to partition index
<span class="nc" id="L191">        temp = data[min];</span>
<span class="nc" id="L192">        data[min] = data[right];</span>
<span class="nc" id="L193">        data[right] = temp;</span>
         
<span class="nc" id="L195">        return right;</span>
    }

    /**
    * Sorts the specified array of objects using the merge sort
    * algorithm.
    * Recursive algorithm
    *
    * @param data the array to be sorted
    * @param min the integer representation of the minimum value
    * @param max the integer representation of the maximum value
    */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void
        mergeSort (T[] data, int min, int max) {
        T[] temp;
        int index1, left, right;
        
        // return on list of length one
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (min == max)</span>
<span class="nc" id="L214">            return;</span>
        
        // find the length and the midpoint of the list
<span class="nc" id="L217">        int size = max - min + 1;</span>
<span class="nc" id="L218">        int pivot = (min + max) / 2;</span>
<span class="nc" id="L219">        temp = (T[])(new Comparable[size]);</span>
<span class="nc" id="L220">        mergeSort(data, min, pivot); // sort left half of list</span>
<span class="nc" id="L221">        mergeSort(data, pivot + 1, max); // sort right half of list</span>
        
        // copy sorted data into workspace
<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (index1 = 0; index1 &lt; size; index1++)</span>
<span class="nc" id="L225">            temp[index1] = data[min + index1];</span>
      
        // merge the two sorted lists
<span class="nc" id="L228">        left = 0;</span>
<span class="nc" id="L229">        right = pivot - min + 1;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (index1 = 0; index1 &lt; size; index1++) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (right &lt;= max - min)</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (left &lt;= pivot - min)</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if (temp[left].compareTo(temp[right]) &gt; 0)</span>
<span class="nc" id="L234">                        data[index1 + min] = temp[right++];</span>
                    else
<span class="nc" id="L236">                        data[index1 + min] = temp[left++];</span>
                else
<span class="nc" id="L238">                    data[index1 + min] = temp[right++];</span>
            else
<span class="nc" id="L240">                data[index1 + min] = temp[left++];</span>
        }
<span class="nc" id="L242">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>